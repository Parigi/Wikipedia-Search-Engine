<mediawiki xmlns="http://www.mediawiki.org/xml/export-0.10/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.mediawiki.org/xml/export-0.10/ http://www.mediawiki.org/xml/export-0.10.xsd" version="0.10" xml:lang="en">
  <siteinfo>
    <sitename>Wikipedia</sitename>
    <dbname>enwiki</dbname>
    <base>https://en.wikipedia.org/wiki/Main_Page</base>
    <generator>MediaWiki 1.35.0-wmf.36</generator>
    <case>first-letter</case>
    <namespaces>
      <namespace key="-2" case="first-letter">Media</namespace>
      <namespace key="-1" case="first-letter">Special</namespace>
      <namespace key="0" case="first-letter" />
      <namespace key="1" case="first-letter">Talk</namespace>
      <namespace key="2" case="first-letter">User</namespace>
      <namespace key="3" case="first-letter">User talk</namespace>
      <namespace key="4" case="first-letter">Wikipedia</namespace>
      <namespace key="5" case="first-letter">Wikipedia talk</namespace>
      <namespace key="6" case="first-letter">File</namespace>
      <namespace key="7" case="first-letter">File talk</namespace>
      <namespace key="8" case="first-letter">MediaWiki</namespace>
      <namespace key="9" case="first-letter">MediaWiki talk</namespace>
      <namespace key="10" case="first-letter">Template</namespace>
      <namespace key="11" case="first-letter">Template talk</namespace>
      <namespace key="12" case="first-letter">Help</namespace>
      <namespace key="13" case="first-letter">Help talk</namespace>
      <namespace key="14" case="first-letter">Category</namespace>
      <namespace key="15" case="first-letter">Category talk</namespace>
      <namespace key="100" case="first-letter">Portal</namespace>
      <namespace key="101" case="first-letter">Portal talk</namespace>
      <namespace key="108" case="first-letter">Book</namespace>
      <namespace key="109" case="first-letter">Book talk</namespace>
      <namespace key="118" case="first-letter">Draft</namespace>
      <namespace key="119" case="first-letter">Draft talk</namespace>
      <namespace key="446" case="first-letter">Education Program</namespace>
      <namespace key="447" case="first-letter">Education Program talk</namespace>
      <namespace key="710" case="first-letter">TimedText</namespace>
      <namespace key="711" case="first-letter">TimedText talk</namespace>
      <namespace key="828" case="first-letter">Module</namespace>
      <namespace key="829" case="first-letter">Module talk</namespace>
      <namespace key="2300" case="first-letter">Gadget</namespace>
      <namespace key="2301" case="first-letter">Gadget talk</namespace>
      <namespace key="2302" case="case-sensitive">Gadget definition</namespace>
      <namespace key="2303" case="case-sensitive">Gadget definition talk</namespace>
    </namespaces>
  </siteinfo>
  <page>
    <title>High-level programming language</title>
    <ns>0</ns>
    <id>189842</id>
    <revision>
      <id>948220318</id>
      <parentid>948191935</parentid>
      <timestamp>2020-03-30T20:18:24Z</timestamp>
      <contributor>
        <username>Mindmatrix</username>
        <id>160367</id>
      </contributor>
      <minor/>
      <comment>Reverted edits by [[Special:Contribs/2402:3A80:972:83DF:0:6B:C398:3901|2402:3A80:972:83DF:0:6B:C398:3901]] ([[User talk:2402:3A80:972:83DF:0:6B:C398:3901|talk]]) to last version by Mindmatrix</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="16471" xml:space="preserve">{{short description|Programming language with strong abstraction from details of hardware}}
{{Use American English|date=January 2019}}{{Short description|Programming language with strong abstraction from details of hardware
}}
In [[computer science]], a '''high-level programming language''' is a [[programming language]] with strong [[Abstraction (computer science)|abstraction]] from the details of the [[computer]]. In contrast to [[low-level programming language]]s, it may use [[natural language]] ''elements'', be easier to use, or may automate (or even hide entirely) significant areas of computing systems (e.g. [[memory management]]), making the process of developing a program simpler and more understandable than when using a lower-level language. The amount of abstraction provided defines how "high-level" a programming language is.&lt;ref&gt;[https://web.archive.org/web/20070826224349/http://www.ittc.ku.edu/hybridthreads/glossary/index.php HThreads - RD Glossary&lt;!-- Bot generated title --&gt;]&lt;/ref&gt;

In the 1960s, high-level programming languages using a [[compiler]] were commonly called '''[[autocode]]s'''.&lt;ref name=kleith&gt;{{cite book|last=London|first=Keith|title=Introduction to Computers|year=1968|publisher=Faber and Faber Limited|location=24 Russell Square London WC1|isbn=0571085938|page=184|chapter=4, Programming|quote=The 'high' level programming languages are often called autocodes and the processor program, a compiler.}}&lt;!--the book does not have an ISBN number, instead it has an SBN number. There is no typo in the previous sentence.--&gt;&lt;/ref&gt;
Examples of autocodes are [[COBOL]] and [[Fortran]].&lt;ref name=kleith2&gt;{{cite book|last=London|first=Keith|title=Introduction to Computers|year=1968|publisher=Faber and Faber Limited|location=24 Russell Square London WC1|isbn=0571085938|page=186|chapter=4, Programming|quote=Two high level programming languages which can be used here as examples to illustrate the structure and purpose of autocodes are COBOL (Common Business Oriented Language) and FORTRAN (Formular Translation).}}&lt;!--the book does not have an ISBN number, instead it has an SBN number. There is no typo in the previous sentence.--&gt;&lt;/ref&gt;

The first high-level programming language designed for computers was [[Plankalkül]], created by [[Konrad Zuse]].&lt;ref&gt;{{ill|Wolfgang Giloi{{!}}Giloi, Wolfgang, K.|de|Wolfgang Giloi}} (1997). "Konrad Zuse's Plankalkül: The First High-Level "non von Neumann" Programming Language". IEEE Annals of the History of Computing, vol. 19, no. 2, pp.&amp;nbsp;17–24,  April–June, 1997. [http://doi.ieeecomputersociety.org/10.1109/85.586068 (abstract)]&lt;/ref&gt; However, it was not implemented in his time, and his original contributions were largely isolated from other developments due to [[World War II]], aside from the language's influence on the "Superplan" language by [[Heinz Rutishauser]] and also to some degree [[ALGOL|Algol]]. The first significantly widespread high-level language was [[Fortran]], a machine-independent development of IBM's earlier [[Autocode]] systems. [[ALGOL|Algol]], defined in 1958 and 1960 by committees of European and American computer scientists, introduced [[recursion]] as well as [[nested functions]] under [[lexical scope]]. It was also the first language with a clear distinction between [[call by value|value]] and [[call by name|name-parameter]]s and their corresponding [[semantics]].&lt;ref&gt;Although it lacked a notion of [[call by reference|reference-parameter]]s, which could be a problem in some situations. Several successors, including [[AlgolW]], [[Algol68]], [[Simula]], [[Pascal (programming language)|Pascal]], [[Modula]] and [[Ada (programming language)|Ada]] therefore included reference-parameters (The related C-language family instead allowed addresses as '''value'''-parameters).&lt;/ref&gt; Algol also introduced several [[structured programming]] concepts, such as the '''while-do''' and '''if-then-else''' constructs and its [[syntax]] was the first to be described in formal notation – "[[Backus–Naur form]]" (BNF). During roughly the same period, [[Cobol]] introduced [[record (computer science)|record]]s (also called structs) and [[Lisp (programming language)|Lisp]] introduced a fully general [[lambda abstraction]] in a programming language for the first time.

== Features ==
"High-level language" refers to the higher level of abstraction from [[machine language]]. Rather than dealing with registers, memory addresses and call stacks, high-level languages deal with variables, arrays, [[object (computer science)|object]]s, complex arithmetic or boolean expressions, subroutines and functions, loops, [[Thread (computer science)|thread]]s, locks, and other abstract computer science concepts, with a focus on [[usability]] over optimal program efficiency. Unlike low-level [[assembly language]]s, high-level languages have few, if any, language elements that translate directly into a machine's native [[opcode]]s. Other features, such as string handling routines, object-oriented language features, and file input/output, may also be present. One thing to note about high-level programming languages is that these languages allow the programmer to be detached and separated from the machine. That is, unlike low-level languages like assembly or machine language, high-level programming can amplify the programmer's instructions and trigger a lot of data movements in the background without their knowledge. The responsibility and power of executing instructions have been handed over to the machine from the programmer.

== Abstraction penalty ==
High-level languages intend to provide features which standardize common tasks, permit rich debugging, and maintain architectural agnosticism; while low-level languages often produce more efficient code through [[program optimization|optimization]] for a specific system architecture. ''Abstraction penalty'' is the cost that high-level programming techniques pay for being unable to optimize performance or use certain hardware because they don't take advantage of certain low-level architectural resources. High-level programming exhibits features like more generic data structures and operations, run-time interpretation, and intermediate code files; which often result in execution of far more operations than necessary, higher memory consumption, and larger binary program size.&lt;ref&gt;{{cite journal
 |author=Surana P 
 |title=Meta-Compilation of Language Abstractions. 
 |year=2006 
 |url=ftp://lispnyc.org/meeting-assets/2007-02-13_pinku/SuranaThesis.pdf 
 |accessdate=2008-03-17 
 |url-status=dead 
 |archiveurl=https://web.archive.org/web/20150217154926/http://lispnyc.org/meeting-assets/2007-02-13_pinku/SuranaThesis.pdf 
 |archivedate=2015-02-17 
}}&lt;/ref&gt;&lt;ref&gt;{{cite web
  | last = Kuketayev
  | title = The Data Abstraction Penalty (DAP) Benchmark for Small Objects in Java.
  | url = http://www.adtmag.com/joop/article.aspx?id=4597
  | accessdate = 2008-03-17
  | archive-url = https://web.archive.org/web/20090111091710/http://www.adtmag.com/joop/article.aspx?id=4597
  | archive-date = 2009-01-11
  | url-status = dead
  }}&lt;/ref&gt;&lt;ref&gt;{{Cite book
  | last = Chatzigeorgiou
  | last2 = Stephanides
  | editor-last = Blieberger
  | editor2-last = Strohmeier
  | contribution = Evaluating Performance and Power Of Object-Oriented Vs. Procedural Programming Languages
  | title = Proceedings - 7th International Conference on Reliable Software Technologies - Ada-Europe'2002
  | year = 2002
  | pages = 367
  | publisher = Springer
  | postscript = &lt;!--None--&gt;
 }}&lt;/ref&gt; For this reason, code which needs to run particularly quickly and efficiently may require the use of a lower-level language, even if a higher-level language would make the coding easier. In many cases, critical portions of a program mostly in a high-level language can be hand-coded in [[assembly language]], leading to a much faster, more efficient, or simply reliably functioning [[Program optimisation|optimised program]].

However, with the growing complexity of modern [[microprocessor]] architectures, well-designed compilers for high-level languages frequently produce code comparable in efficiency to what most low-level programmers can produce by hand, and the higher abstraction may allow for more powerful techniques providing better overall results than their low-level counterparts in particular settings.&lt;ref&gt;
{{Cite journal
  |author1=Manuel Carro |author2=José F. Morales |author3=Henk L. Muller |author4=G. Puebla |author5=M. Hermenegildo | journal = Proceedings of the 2006 International Conference on Compilers, Architecture and Synthesis for Embedded Systems
  | title = High-level languages for small devices: a case study
  | url = http://www.clip.dia.fi.upm.es/papers/carro06:stream_interpreter_cases.pdf
  | year = 2006
  | publisher = ACM
  | postscript = &lt;!--None--&gt;
}}&lt;/ref&gt;
High-level languages are designed independent of a specific computing system architecture. This facilitates executing a program written in such a language on any computing system with compatible support for the Interpreted or [[Just-in-time compilation|JIT]] program. High-level languages can be improved as their designers develop improvements. In other cases, new high-level languages evolve from one or more others with the goal of aggregating the most popular constructs with new or improved features. An example of this is [[Scala (programming language)|Scala]] which maintains backward compatibility with [[Java (programming language)|Java]] which means that programs and libraries written in Java will continue to be usable even if a programming shop switches to Scala; this makes the transition easier and the lifespan of such high-level coding indefinite. In contrast, low-level programs rarely survive beyond the system architecture which they were written for without major revision. This is the engineering 'trade-off' for the 'Abstraction Penalty'.

== Relative meaning ==
{{unreferenced section|small=y|date=October 2018}}
Examples of high-level programming languages in active use today include [[Python (programming language)|Python]], [[Visual Basic]], [[Delphi (programming language)|Delphi]], [[Perl]], [[PHP]], [[ECMAScript]], [[Ruby (programming language)|Ruby]], [[C Sharp (programming language)|C#]], [[Java (programming language)|Java]] and many others.

The terms ''high-level'' and ''low-level'' are inherently relative. Some decades ago, the [[C (programming language)|C language]], and similar languages, were most often considered "high-level", as it supported concepts such as expression evaluation, [[parameter]]ised recursive functions, and data types and structures, while [[assembly language]] was considered "low-level".  Today, many programmers might refer to C as low-level, as it lacks a large [[Run time system|runtime]]-system (no garbage collection, etc.), basically supports only scalar operations, and provides direct memory addressing. It, therefore, readily blends with assembly language and the machine level of [[CPU]]s and [[microcontroller]]s.

Assembly language may itself be regarded as a higher level (but often still one-to-one if used without [[Macro (computer science)|macro]]s) representation of [[machine code]], as it supports concepts such as constants and (limited) expressions, sometimes even variables, procedures, and [[data structure]]s. [[Machine code]], in its turn, is inherently at a slightly higher level than the [[microcode]] or [[micro-operation]]s used internally in many processors.&lt;ref&gt;{{Cite book|title=The art of assembly language|last=Hyde, Randall.|date=2010|publisher=No Starch Press|isbn=9781593273019|edition= 2nd|location=San Francisco|oclc=635507601}}&lt;/ref&gt;

== Execution modes ==
{{unreferenced section|small=y|date=October 2018}}
There are three general modes of execution for modern high-level languages:
; Interpreted: When code written in a language is [[Interpreted language|interpreted]], its syntax is read and then executed directly, with no compilation stage. A program called an ''interpreter'' reads each program statement, following the program flow, then decides what to do, and does it. A hybrid of an interpreter and a compiler will compile the statement into machine code and execute that; the machine code is then discarded, to be interpreted anew if the line is executed again. Interpreters are commonly the simplest implementations of the behavior of a language, compared to the other two variants listed here.
; Compiled: When code written in a language is [[Compiled language|compiled]], its syntax is transformed into an executable form before running. There are two types of compilation:
:; Machine code generation: Some compilers compile source code directly into [[machine code]]. This is the original mode of compilation, and languages that are directly and completely transformed to machine-native code in this way may be called ''truly compiled'' languages. See [[assembly language]].
:; Intermediate representations: When code written in a language is compiled to an intermediate representation, that representation can be optimized or saved for later execution without the need to re-read the source file. When the intermediate representation is saved, it may be in a form such as [[bytecode]]. The intermediate representation must then be interpreted or further compiled to execute it. [[Virtual machine]]s that execute bytecode directly or transform it further into machine code have blurred the once clear distinction between intermediate representations and truly compiled languages.
; Source-to-source translated or transcompiled: Code written in a language may be translated into terms of a lower-level language for which native code compilers are already common. [[JavaScript]] and the language [[C (programming language)|C]] are common targets for such translators. See [[CoffeeScript]], [[Chicken (Scheme implementation)|Chicken]] Scheme, and [[Eiffel (programming language)|Eiffel]] as examples. Specifically, the generated C and C++ code can be seen (as generated from the Eiffel language when using the [[EiffelStudio]] IDE) in the EIFGENs directory of any compiled Eiffel project. In Eiffel, the ''translated'' process is referred to as transcompiling or transcompiled, and the Eiffel compiler as a transcompiler or [[source-to-source compiler]].

Note that languages are not strictly ''interpreted'' languages or ''compiled'' languages. Rather, implementations of language behavior use interpreting or compiling. For example, [[ALGOL 60]] and [[Fortran]] have both been interpreted (even though they were more typically compiled). Similarly, Java shows the difficulty of trying to apply these labels to languages, rather than to implementations; Java is compiled to bytecode which is then executed by either interpreting (in a [[Java virtual machine]] (JVM)) or compiling (typically with a just-in-time compiler such as [[HotSpot]], again in a JVM). Moreover, compiling, transcompiling, and interpreting are not strictly limited to only a description of the compiler artifact (binary executable or IL assembly).

===High-level language computer architecture===

Alternatively, it is possible for a high-level language to be directly implemented by a computer – the computer directly executes the HLL code. This is known as a ''[[high-level language computer architecture]]'' – the [[computer architecture]] itself is designed to be targeted by a specific high-level language. The [[Burroughs large systems]] were target machines for [[ALGOL 60]], for example.&lt;ref&gt;{{Citation|last=Chu|first=Yaohan|chapter=Concepts of High-Level Language Computer Architecture|date=1975|pages=1–14|publisher=Elsevier|isbn=9780121741501|doi=10.1016/b978-0-12-174150-1.50007-0|title=High-Level Language Computer Architecture}}&lt;/ref&gt;

== See also ==
{{Portal|Computer programming}}
* [[Abstraction (computer science)]]
* [[Generational list of programming languages]]
* [[Low-level programming language]]s
* [[High-level assembler]]
* [[Very high-level programming language]]s
* [[Categorical list of programming languages]]
{{Clear}}

== References ==
{{Reflist}}

== External links ==
* http://c2.com/cgi/wiki?HighLevelLanguage - The [[WikiWikiWeb]]'s article on high-level programming languages

{{Programming language}}

{{Authority control}}

{{DEFAULTSORT:High-Level Programming Language}}
[[Category:High-level programming languages| ]]
[[Category:Programming language classification]]</text>
      <sha1>i76qqadxk04mdk940ofh74w43bugvqw</sha1>
    </revision>
  </page>
</mediawiki>
